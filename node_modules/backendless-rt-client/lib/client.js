"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

var _config = _interopRequireDefault(require("./config"));

var _subscriptions = _interopRequireDefault(require("./subscriptions"));

var _methods = _interopRequireDefault(require("./methods"));

var _session = _interopRequireDefault(require("./session"));

var CONNECTION_MANAGE_EVENTS = [_constants.NativeSocketEvents.CONNECTING, _constants.NativeSocketEvents.CONNECT, _constants.NativeSocketEvents.CONNECT_ERROR, _constants.NativeSocketEvents.DISCONNECT, _constants.NativeSocketEvents.RECONNECT_ATTEMPT];

var RTClient = /*#__PURE__*/function () {
  function RTClient(config) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, RTClient);
    (0, _defineProperty2["default"])(this, "onConnectError", function () {
      if (!_this.subscriptions.hasActivity() && !_this.methods.hasActivity()) {
        _this.disconnect('There are no active subscriptions and methods');

        _this.connectible = true;
      }
    });
    (0, _defineProperty2["default"])(this, "connectOnMethod", function (method) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (_this.connectible) {
          var rtSocketPromise = _this.provideConnection();

          if (_this.connected) {
            rtSocketPromise.then(function (rtSocket) {
              return rtSocket[method].apply(rtSocket, args);
            });
          }
        }
      };
    });
    (0, _defineProperty2["default"])(this, "on", this.connectOnMethod('on'));
    (0, _defineProperty2["default"])(this, "emit", this.connectOnMethod('emit'));
    (0, _defineProperty2["default"])(this, "onSessionDisconnect", function () {
      _this.subscriptions.stop();

      _this.methods.stop();

      delete _this.session;

      _this.provideConnection();
    });
    (0, _defineProperty2["default"])(this, "emitSocketEventListeners", function (event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (_this.socketEvents[event]) {
        _this.socketEvents[event].forEach(function (callback) {
          return callback.apply(void 0, args);
        });
      }
    });
    (0, _defineProperty2["default"])(this, "addConnectingEventListener", function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECTING, callback);
    });
    (0, _defineProperty2["default"])(this, "removeConnectingEventListener", function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECTING, callback);
    });
    (0, _defineProperty2["default"])(this, "addConnectEventListener", function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECT, callback);
    });
    (0, _defineProperty2["default"])(this, "removeConnectEventListener", function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECT, callback);
    });
    (0, _defineProperty2["default"])(this, "addConnectErrorEventListener", function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECT_ERROR, callback);
    });
    (0, _defineProperty2["default"])(this, "removeConnectErrorEventListener", function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECT_ERROR, callback);
    });
    (0, _defineProperty2["default"])(this, "addDisconnectEventListener", function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.DISCONNECT, callback);
    });
    (0, _defineProperty2["default"])(this, "removeDisconnectEventListener", function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.DISCONNECT, callback);
    });
    (0, _defineProperty2["default"])(this, "addReconnectAttemptEventListener", function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, callback);
    });
    (0, _defineProperty2["default"])(this, "removeReconnectAttemptEventListener", function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, callback);
    });
    (0, _defineProperty2["default"])(this, "removeConnectionListeners", function () {
      CONNECTION_MANAGE_EVENTS.forEach(function (event) {
        return _this.removeSocketEventListener(event);
      });
    });
    this.config = new _config["default"](config);
    this.resetSocketEvents();
    var socketContext = {
      onMessage: this.on.bind(this),
      emitMessage: this.emit.bind(this)
    };
    this.subscriptions = new _subscriptions["default"](socketContext);
    this.methods = new _methods["default"](socketContext);
    this.connectible = true;
    this.connected = false;
  }

  (0, _createClass2["default"])(RTClient, [{
    key: "resetSocketEvents",
    value: function resetSocketEvents() {
      this.socketEvents = {};
      this.addConnectErrorEventListener(this.onConnectError);
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      this.config.set(config);

      if (this.session) {
        this.disconnect('Re-config socket connection');
        this.connect();
      }
    }
  }, {
    key: "provideConnection",
    value: function provideConnection() {
      var _this2 = this;

      if (!this.session) {
        this.session = new _session["default"](this.config, this.emitSocketEventListeners, this.onSessionDisconnect);
        this.session.getSocket().then(function () {
          _this2.connected = true;

          _this2.methods.initialize();

          _this2.methods.restore();

          _this2.subscriptions.initialize();

          _this2.subscriptions.restore();
        });
      }

      return this.session.getSocket();
    }
  }, {
    key: "connect",
    value: function connect() {
      this.connectible = true;
      this.provideConnection();
    }
  }, {
    key: "disconnect",
    value: function disconnect(reason) {
      if (this.session) {
        this.subscriptions.stop();
        this.methods.stop();
        this.session.terminate();
        delete this.session;
        this.emitSocketEventListeners(_constants.NativeSocketEvents.DISCONNECT, reason || 'disconnected by client');
      }

      this.connectible = false;
      this.connected = false;
    }
  }, {
    key: "terminate",
    value: function terminate(reason) {
      this.resetSocketEvents();
      this.subscriptions.reset();
      this.methods.reset();
      this.disconnect(reason || 'Terminated by client');
    }
  }, {
    key: "addSocketEventListener",
    value: function addSocketEventListener(event, callback) {
      this.socketEvents[event] = this.socketEvents[event] || [];
      this.socketEvents[event].push(callback);
      return this;
    }
  }, {
    key: "removeSocketEventListener",
    value: function removeSocketEventListener(event, callback) {
      if (this.socketEvents[event]) {
        this.socketEvents[event] = callback ? this.socketEvents[event].filter(function (cb) {
          return cb !== callback;
        }) : [];

        if (!this.socketEvents[event].length) {
          delete this.socketEvents[event];
        }
      }

      return this;
    }
  }]);
  return RTClient;
}();

exports["default"] = RTClient;