"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("./constants");

var _socket = _interopRequireDefault(require("./socket"));

var INCREASE_RECONNECTION_TIMEOUT_STEP = 10;
var INITIAL_RECONNECTION_TIMEOUT = 200;
var MAX_RECONNECTION_TIMEOUT = 60 * 1000; // a minute

var wait = function wait(milliseconds) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, milliseconds);
  });
};

var RTSession = /*#__PURE__*/function () {
  function RTSession(config, dispatch, onDisconnect) {
    (0, _classCallCheck2["default"])(this, RTSession);
    this.config = config;
    this.dispatch = dispatch;
    this.onDisconnect = onDisconnect;
    this.connectAttempt = 0;
    this.socketPromise = this.connect();
  }

  (0, _createClass2["default"])(RTSession, [{
    key: "terminate",
    value: function terminate() {
      if (!this.terminated) {
        this.terminated = true;

        this.dispatch = function () {//if sessions has been terminated don't need to dispatch any events
        };

        this.socketPromise.then(function (rtSocket) {
          if (rtSocket) {
            rtSocket.close();
          }
        });
      }
    }
  }, {
    key: "getSocket",
    value: function getSocket() {
      var _this = this;

      return this.socketPromise.then(function (rtSocket) {
        if (_this.terminated) {
          return new Promise(function () {//return unresolvable promise for preventing errors
            //this connection session has been terminated and a new one will be created if it necessary
          });
        }

        return rtSocket;
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      if (this.terminated) {
        return;
      }

      this.connectAttempt = this.connectAttempt + 1;
      var nextReconnectionTimeout = this.getNextReconnectionTimeout();
      this.onConnecting();

      if (this.connectAttempt > 1) {
        this.onReconnectAttempt(this.connectAttempt - 1, nextReconnectionTimeout);
      }

      return _socket["default"].connect(this.config, this.onSocketDisconnect.bind(this)).then(function (rtSocket) {
        _this2.connectAttempt = 0;

        _this2.onConnect();

        return rtSocket;
      })["catch"](function (error) {
        _this2.onConnectError(error);

        if (!_this2.terminated) {
          // wait for 400|800|1600|...|MAX_RECONNECTION_TIMEOUT milliseconds
          return wait(nextReconnectionTimeout).then(function () {
            return _this2.connect();
          });
        }
      });
    }
  }, {
    key: "getNextReconnectionTimeout",
    value: function getNextReconnectionTimeout() {
      var factor = Math.ceil(this.connectAttempt / INCREASE_RECONNECTION_TIMEOUT_STEP);
      var timeout = INITIAL_RECONNECTION_TIMEOUT * Math.pow(2, factor);
      return Math.min(timeout, MAX_RECONNECTION_TIMEOUT);
    }
  }, {
    key: "onSocketDisconnect",
    value: function onSocketDisconnect(reason) {
      this.dispatch(_constants.NativeSocketEvents.DISCONNECT, reason);

      if (!this.terminated) {
        this.terminate();
        this.onDisconnect();
      }
    }
  }, {
    key: "onConnecting",
    value: function onConnecting() {
      this.dispatch(_constants.NativeSocketEvents.CONNECTING);
    }
  }, {
    key: "onConnect",
    value: function onConnect() {
      this.dispatch(_constants.NativeSocketEvents.CONNECT);
    }
  }, {
    key: "onConnectError",
    value: function onConnectError(error) {
      this.dispatch(_constants.NativeSocketEvents.CONNECT_ERROR, error && error.message || error);
    }
  }, {
    key: "onReconnectAttempt",
    value: function onReconnectAttempt(attempt, timeout) {
      this.dispatch(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, attempt, timeout);
    }
  }]);
  return RTSession;
}();

exports["default"] = RTSession;